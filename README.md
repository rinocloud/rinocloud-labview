# Getting startedThe Rinocloud LabVIEW library is static, and should run on all machines with LabVIEW 2013 version installed (a version for  LabVIEW 2011 is included as well). The unzipped library content can be placed at the location of your choice. To navigate through the library contents, run __Rinocloud Library.lvlib__. Before connecting to Rinocloud, authentication parameters must be set in __Rinocloud_global_variable.vi__.  An authentication token is required and can be obtained by registered and logged in users from https://(_your-project-name_).rinocloud.com/integrations/ An optional parameter __Local storage root path__ points to the folder on the local machine, where the local copies of sent data are saved. ![Global variable](http://i.imgur.com/jhPpFbd.png)__Hint:__ To enter a new project name and the authentication token value, right mouse-click on the Project field (a combo box), select _Edit Items..._ from the menu and enter the details: a project name and the obtained token.  ![Token value](http://i.imgur.com/5tCOM61.png)__Hint:__ To save the values as default, select Edit ->Make Current Values Default, and Save.__Rinocloud_global_variable.vi__ contains additional hidden parameters (identifiers of active files) which are populated automatically by  __Rinocloud_explorer.vi__  and they are meant to improve integration of all LabVIEW software on a single machine using Rinocloud library.# Where to start?A good starting point is the VI __Rinocloud_explorer.vi__ - the tool which allows managing your data from LabVIEW environment. It is built using most of the __Rinocloud API endpoint VIs__ given in the library and represents the functionality of them.  ![Rinocloud explorer](http://i.imgur.com/o1SFawS.png)# NavigationData in Rinocloud is saved and presented as a conventional file-folder system, where each item can have its own metadata. The user can navigate through the content by double-clicking the folders in the tree-lists. __The tree-list #1__ presents full path of the active item. The tree is populated by __Rinocloud_HTTP_ancestors_to_tree.vi__ which is based on __Rinocloud_HTTP_ancestors.vi__ subVI:![Rinocloud_HTTP_ancestors.vi](http://i.imgur.com/A28VqEu.png). __metadata array__ is an array which contains clusters with information about each active item's ancestor. Information, such as ancestor's id, name, metadata, from the clusters can be obtained by _Unbundle By Name_ function. __The tree-list #2__ presents contents of the active folder. ![Rinocloud_HTTP_children.vi](http://i.imgur.com/DLW9Mh6.png)Apart navigation, double-clicking items in the both lists has other effects too. (1) First, double-clicking activates the item (as indicated by __#3__) - a unique information, __id__ of the item is transferred in the background to   __Rinocloud_global_variable.vi__. This information can be accessed from the other LabVIEW programs with Rinocloud library integrations. For example, by navigating to the folder where measurement data have to be saved, the __id__ is transferred to the global variable field __Active folder id__. It can be used within the measurement VI, when data file is saved to a particular folder using __Rinocloud_HTTP_upload_file.vi__ by populating its _Parent ID_ terminal.  (2) Metadata of an active item is received and presented in the tab __Reading & updating metadata (#7)__ # Creating folders and uploading filesTo demonstrate the simplicity of a Rinocloud library integration, a basic functional example of saving numerical data is shown below. This higher-level Virtual Instrument (VI) (__Rinocloud_csv_data_upload.vi__) saves an array of numeric data as a *.csv* file called *data.csv* locally and on the Rinocloud server. Optional inputs of this VI allow saving metadata, which, if needed, can be entered later on Rinocloud web platform or using **Rinocloud_explorer.vi** tool provided within the library. ![A basic functional example](http://i.imgur.com/7JwvzPE.png)The given example represents a specific case, which is not necessary common in all labs. The lower-level VIs should satisfy most of the cases as long as data can be written to a file. The functionality of each VI is described below. After getting familiar with them, it's advisable to analyse three examples __Rinocloud_lab_simulator.vi__,  __Rinocloud_real-time_monitoring.vi__ and __Rinocloud_explorer.vi__, which contain realistic usage cases, such as populating data, metadata variables. A new folder can be created (__#4__) using __Rinocloud_HTTP_create_folder.vi__ __Name__ is a required input.![Rinocloud_HTTP_create_folder.vi](http://i.imgur.com/xwpIYdU.png)A new file can be uploaded (__#5__) using __Rinocloud_HTTP_upload_file.vi__![Rinocloud_HTTP_upload_file.vi](http://i.imgur.com/mIjUorq.png)## Uploading files, saving data__Rinocloud_HTTP_upload_file.vi__ is probably the most widely used VI of the API endpoint VIs. It has a single required terminal __Path In__ - a path pointing to the file for uploading. If the file name is not provided, the original file name will be used. If __Store locally__ is set to _true_(default), the copy is saved locally at the folder pointed by  __Rinocloud_global_variable.vi__. Integration of this VI to the measurement software is shown in two common cases in __Rinocloud_csv_data_upload.vi__ and __Rinocloud_image_upload.vi__. They can be easily customized (for example, formatting of numerical data changed) or applied for different cases.The general data saving strategy is based on writing data to a temporary file, which then is saved locally to a Rinocloud mirror storage and sent to the server with metadata entered.Saving experimentally obtained numerical data to Rinocloud as a spreadsheet file:![csv file](http://i.imgur.com/7poFhEx.png)This VI saves the snapshot of the waveform:![png file](http://i.imgur.com/8Wppm9D.png)__Rinocloud_lab_simulator.vi__ shows both VIs in action.## Saving metadataThe input terminals __Name__, __Tags__, __Notes__, __Extra metadata array__ and __Parent ID__ are used to build JSON payload which holds all metadata (for this purpose, a modified __i3 JSON__ is used).The JSON string is sent to the server, which parses the request and transforms it into in the following form:```python{"name": "string - required","tags": [array – optional],"notes": "string - optional","metadata": {JSON object – optional}}```__Name__, __Notes__ and  __Tags__ are strings. Tags are separated by a comma sign. __Extra metadata array__ enables saving custom metadata by sending them to the VI for the conversion to JSON type attribute-value pairs. These pairs are held as a JSON object in "metadata": {JSON object}. The terminal has to be populated by an array which contains a cluster(s) of 3 elements: 2 strings (1 - required) "attribute", (2 - required) "value" and 1 integer (3 - required) "Data type".  Each cluster is processed to an "attribute":"value" string.1. "attribute" is a string.2. "value" is a string. The field can store a single integer (double) value, text, a single dimension array of strings, a single dimension array of integers (doubles). 3. "Data type" indicates the original data type of information stored in the "value" field, in order to ensure conversion to JSON compatible format. Possible values are: 0 – integer (double), 1 – string, 2 – an array of strings, 3 – an array of integers (doubles), 4 – data JSON string - a string value which is not modified by the encoding library, so it can hold complex structures of information as long as they comply with JSON syntax, 5 – <null> the cluster is ignored.__Hint:__ check __Rinocloud_lab_simulator.vi__ and __Rinocloud_explorer.vi__ for different options how to construct extra metadata array clusters:![Constructing metadata clusters](http://i.imgur.com/0TrSnXz.png)# Managing metadata## Getting metadataMetadata can be obtained by __Rinocloud_HTTP_get_metadata.vi__ The outputs are __Name__, __Tags__, __Notes__ and custom metadata encoded to JSON object (__metadata (JSON)__).![get metadata](http://i.imgur.com/nEJA7vf.png)__metadata (JSON)__ can be easily parsed using __Rinocloud_get_metadata_field_value.vi__, if the key value, and output data types are known. The VI is polymorphic and can give outputs of numeric, string and JSON object values.![get metadata field](http://i.imgur.com/hlE43FD.png)The combination of these two VIs can be used as a remote software or hardware status control. For example, periodically polling a particular value stored in a custom metadata field ({"status":"on"}), the status can be changed. The "status" field can be remotely updated through Rinocloud web platform or other software using Rinocloud API. A functional example is shown in __Rinocloud_real-time_monitoring.vi__.## Updating metadataMetadata can be updated with __Rinocloud_HTTP_update_metadata.vi__ This includes changing the name too.![updatin metadata vi](http://i.imgur.com/3SPpTz4.png)# Data streamingThe combination of two Rinocloud API endpoint VIs, __Rinocloud_HTTP_create_empty.vi__ and __Rinocloud_HTTP_append.vi__, allows live data streaming to the Rinocloud server. The first VI, __Rinocloud_HTTP_create_empty.vi__, creates an empty file with metadata, and the second one, __Rinocloud_HTTP_append.vi__ appends data chunk to the created file. The __chunk__ is a string where multiple values can be stored, for example, separated by a space. ![append vi](http://i.imgur.com/1pWjfQT.png)If the VI is polled periodically, or upon subsequent requests, data streaming is obtained. This data can be accessed by the external software through Rinocloud API and used, for example, for sensor output live-monitoring.  The example is shown in __Rinocloud_real-time_monitoring.vi__.# Rinocloud library![Library tree](http://i.imgur.com/5unYAV2.png)